# MongoDB
{: id="capter_mongo"}

## 概要

MongoDBは、2007年の10月から米国10gen社を中心として開発されたオープンソースのドキュメントDBです。のちに10gen社はMongoDB,Incに社名を変更し、2013年10月には約150億円の資金調達に成功し、現在でも活発に開発が行われています。

MongoDBのデータモデルはJSONであり、格納したJSONに対してMongoクエリ言語という独自言語でクエリをかけられます。また、KVSと同様にデータを分散して処理を分散するシャーディングや、可用性を高めるレプリケーションもできます。

MongoDBは現在もっとも広く使われているNoSQLであり、DB-ENGINES[^db-engines]によると2015年12月時点で全体のデータベースの中で4位であり、PostreSQLと同程度に使われています。MongoDBはKVSが最盛期だったころに、ドキュメントDBの先駆けとして登場しました。MongoDBは当時のドキュメントDBと比較しても早い段階からJSONを扱う豊富な機能を提供していました。また導入が簡単ですぐ使える事、そしてそれまでのKVSとは異なりRDBを利用していた人に理解しやすいように設計されること等により一気に人気高まり、現在の普及率に至っています。また、MongoDBを単体で使うという使われ方の他にも、Webフレームワークに組み込まれたり、CRMソフトウェアに組み込まれるといった、従来MySQLやPostgreSQLが占めていた位置の一部をMongoDBが担っています。

[^db-engines]: http://db-engines.com/en/ranking

最も多いユースケースの一つはWebアプリケーションやオンラインゲームのバックエンドで用いる場合でしょう。これらのアプリケーションではユーザの増減に合わせて性能を伸縮できるスケールアウトの特性が必須であり、加えてキーバリューでは表現できない複雑なデータ構造を扱う必要があるためです。

他にも、ログ蓄積の用途も多く使われます。ログは出力元によって型の異なる半構造データであるため、RDBには向いていません。なのでログをJSONに変換して、MongoDBに格納する使い方がよく使われます。特に、ログ収集フレームワークであるfluentdでログを集めてMongoDBに入れるという使いが多いです。MongoDBに入れてレプリケーションを組んでおけば、大事なログが失われることがありませんし、期限付きインデックスを貼っておけば自動的に古いログを引き落としてくれます。


### MongoDBの主な特徴

MongoDBの主な特徴は以下の通りです

- Mongoクエリ言語は機能が豊富
- JSONの一部を書き換える、JSONの中の配列に値を入れる等、JSONを扱う豊富な機能がある
- 配列の要素にインデックスを張る、一部のJSONだけをインデックスに含める等、インデックスが豊富
- アグリゲーションフレームワークでは、集計、絞り込み、配列展開、結合などの様々なフィルタをパイプラインで組み合わせて計算することができ、複雑な集計ができる
- バージョン3.0からは、書き込みのロックがドキュメント単位(以前はデータベース単位)になり、書き込み性能向上
- バージョン3.2からはドキュメントの型をチェックできるバリデーション機能を搭載。何が入っているかわからなくなる問題を回避
- レプリケーションでは、オンラインリクエストを受け付けない分析用のhiddenレプリカや、ヒューマンエラー対策の遅延レプリカ等、さまざまな種類が選べる
- シャーディングでは、分散キーがハッシュだけでなく、キーの範囲やそれらの組み合わせ等さまざまなで分散でき、クエリに合わせて最適な分散構成が可能
- 運用では、MongoDB Ops Managerが提供されており、監視、自動アラート、差分バックアップ、ポイントインタイムリカバリ、自動バージョンアップなど、様々な機能を搭載
- セキュリティでは、基本的な機能に加え、データ暗号化や高度な認証連携が可能
- MongoDB Compassを用いれば、中に入っているデータを可視化できる
- 一つのバイナリで完結しており、そのバイナリを置くだけでインストールが完了するため、簡単
- 国内でも普及率No1であり、インターネットを検索した時の情報量が豊富

## データモデル

MongoDBがどのようにデータを格納するか解説します。

### 格納するデータの階層

MongoDBは起動すると一つのプロセスが起動し、そのプロセスは複数のデータベースを扱えます。データベースの中には、コレクションと呼ばれるRDBでテーブルに相当するデータ構造があり、そのコレクションの中にドキュメント=JSONが格納されます([[img_mongo-datamodel]])。より正確にはJSONをバイナリエンコードしたBSON[^bson]という形式で格納されますが、本書では理解を簡単にするために、BSONの事をJSONと表記します。

![MongoDBのデータモデル](image/img_mongo-datamodel.png){: id="img_mongo-datamodel"}

[^bson]: BSONはJSONをバイナリ形式にエンコードしたものであり、元のJSONに対してｍMongoDBで用いるための幾つか型を追加しています。

JSONはキーと値をペアを格納しますが、値には配列やJSONそのもの(サブドキュメントとも言います)を格納できるため、階層構造のデータが表現できます[[code_mongo-json]]。JSONはもともとJavascriptで用いる連想配列でしたが、XMLよりも簡単に書ける階層データ構造として、コンピュータ間の通信で広く普及しています。JSONの例を[[code_mongo-json]]に示します。

{: title="JSONの例" id="code_mongo-json"}
~~~
｛
  ID      :  12345 , 
  name    : "渡部",
  address : {
                 City   : "東京",
                 ZipNo : "045-3356",
            },
  friendID: [ 3134 , 10231 , 10974 , 11165 ] , 
  hobbies : [
                { name : "自転車" , "year" : 6 } ,
                { name : "インターネット" , "year" : 10 } ,
                { name : "読書" , "no" : 16 } 
            ]
}
~~~

### 格納できるデータ型

MongoDBでは様々なデータ型を格納できます。JSON(BSON)に格納できる代表的な型一覧を[[table_mongo_datatype]]に示します。

{: title="JSON(BSON)に格納できる代表的な型一覧" id="table_mongo_datatype" }
|型                 | 説明|
|:------------------| :------------------------------|
|Boolean            | 真偽値|
|32-bit integer     | 符号付き32bit整数 |
|64-bit integer     | 符号付き64bit整数|
|Double             | 倍精度浮動小数点数(IEEE_754) |
|String             | 文字列|
|Regular Expression | 正規表現|
|Date               | 日時(Unix epoch[^unix-epoch]からの経過ミリ秒)|
|Binary data        | バイナリ|
|Object id          | オブジェクトID(ドキュメントに付与される12byteのIDを参照するときに使う)|
|Null               | Null値|
|Array              | 配列|
|Object             | 入れ子ドキュメント|

[^unix-epoch]: Unix epochとは1970年1月1日 00:00:00.000のこと

### JSONのスキーマの事前チェック(ドキュメントバリデーション)

MongoDB 3.2から格納するJSONに対して、列の存在や値の型をチェックすることができるドキュメントバリデーションの機能が導入されました。これにより事前に決められた型のJSONしか挿入することができなくなります。

MongoDBはもともとスキーマを定義せずにデータを格納できることを売りにしてきましたが、アプリケーションによってはスキーマがあったほうが開発や保守が容易である事が明らかになってきたため、スキーマをチェックできる機能を搭載してきました。

## API

MongoDBが格納したデータをアプリケーションからどのように扱うのかを説明します。

### Mongoクエリ言語の概要

MongoDBはMongoクエリ言語という独自のクエリ言語で問い合わせを行います。まず初めに簡単なサンプルを見ていただくとイメージが沸くでしょう。

MongoDBを起動して、付属のMongoシェルでつなぐと、コマンドを待ち受ける状態になります。そこで、ドキュメントを挿入するには、以下のようなコマンドになります。

~~~
> use mydb
> db.users.insert({ "age" : 30, name : "watanabe", friend_id : [2,6,8]})
~~~

最初のコマンドでは、`mydb`というデータベースを指定しています。次の行では指定したデータベースの`users`というコレクションに`{ "age" : 30, name : "watanabe", friend_id : [2,6,8]}`というJOSNを挿入しています。データベースの定義やコレクションのスキーマは定義する必要がないため、いきなりJSONを挿入できます。

次に、検索する例を見てみましょう。

~~~
> db.users.find({"age" : 30 })
~~~

このコマンドでは、参照を行う`find`メソッドに対して、`{"age" : 30 }`という絞り込み条件を表すJSONを渡しています。これにより、`age`が30であるドキュメントに絞り込んでいます。結果は以下のように出力されます。

~~~
クエリの結果
{ "_id" : ObjectId("563db56fe9da9ab86d705da8"), "age" : 30, "name" : "watanabe", "friend_id" : [ 2, 6, 8 ] }
~~~

いかがでしょうか？非常に簡単だと思います。これはMongoDB付属のMongoシェルから実行した例ですが、アプリケーションからもほとんど同じような使い勝手でデータの操作ができます。

### CRUDのサンプル

ではデータのCRUD操作を、サンプルコードを交えながら紹介してきましょう。

#### Create

まずはコレクションにJSONを挿入してみましょう。

以下の例ではコレクション`user`の中に2つのドキュメントを入れています。スキーマレスですので、コレクションの定義などは一切必要ありません。いきなりJSONを挿入できます。

~~~
db.user.insert(
   {"name" :"suzuki",
    "age"  :30,
    "like" :["book","movie","cooking"] }
)
db.user.insert(
   {"name" :"katoh",
    "age"  :26,
    "like" :["movie","cooking","baseball"]})
~~~

#### Read

次に入れたデータを検索してみましょう。全件検索する場合はfindを用います。

~~~
db.user.find()
~~~

すると、以下の様に表示されます。_idは勝手にMongoDBが付与するIDです。

~~~
{ "_id" : ObjectId("5691f2901ca4e321e182c7d3"), "name" : "suzuki", "age" : 30, "like" : [ "book", "movie", "cooking" ] }
{ "_id" : ObjectId("5691f2a41ca4e321e182c7d4"), "name" : "katoh", "age" : 26, "like" : [ "movie", "cooking", "baseball" ] }
~~~

検索に条件を付ける場合は、条件をJSONの形式で渡します。次の例では"name"が"suzuki"であるJSONを検索しています。

~~~
db.user.find({"name":"suzuki"})
~~~

#### Update

次に更新してみましょう。例えば、"name"が"suzuki"であるJSONの"age"を27にするのは、以下のようなクエリになります。updateに渡す最初の引数が、絞り込み条件を表すJSONであり、二つ目の引数が更新する内容です。

~~~
db.user.update({"name":"katoh"},{$set:{"age":27}})
~~~

これにより、JSONの中身のageの値だけを更新できました。

他にも配列に要素を追加することもできます。以下の例では、likeの配列にfishingを追加しています。

~~~
db.user.update({"name":"katoh"},{$push:{"like":"fishing"}})
~~~

#### Delete

最後に以下のコマンドで削除してみましょう。

~~~
db.user.remove({"name":"katoh"})
~~~

### CRUDの特徴

MongoDBはシンプルなCRUD以外にも、検索と挿入を一回のクエリでupsertオプションや、重複を除去するdistinctメソッド、一括で処理するマルチインサートやマルチアップデートが利用できます。

また、JSONの中身に対するオペレーションも豊富で、配列の要素追加削除、数値のインクリメント、キー名の変更をはじめとして、様々な機能が使えます。

そして、findクエリの修飾として、ドキュメント数を制限するlimit、指定の数だけドキュメントを読み飛ばすskip、そして指定したキーで並べ替えるsortが使えます。

これらはRDBを利用していた人にとって見れば当たり前の機能に思えますが、NoSQLでは当たり前の機能ではありません。


### 集計

MongoDBではAggregationというメソッドで集計を行うことができます。集計はいくつかのフィルタをパイプラインで組み合わせて集計します[[img_mongo-aggregation]]。これをアグリゲーションパイプラインと呼びます。

![アグリゲーションパイプラインの処理イメージ](image/img_mongo-aggregation.png){: id="img_mongo-aggregation"}

集計クエリもサンプルを見てみましょう。

~~~
db.zipcodes.aggregate(
  [
     { $group: { _id: "$state", totalPop: { $sum: "$pop" } } },
     { $match: { totalPop: { $gte: 10000000 } } }
  ]
)
~~~

上記の例では、zipcodesという郵便番号を表すコレクションに対して集計をしています。フィルタの一つ目は`$group`であり`state`の値で集約して、値として`pop`の合計値を計算して`totalPop`に格納することを意味しています。フィルタの二つ目は`$match`であり、集約した結果で`totalPop`が1000万人以上の場合のドキュメントに結果を絞り込んでいます。

利用できるフィルタの種類は以下の通りです。

{: title="アグリゲーションパイプラインで利用できるフィルタ"}
| フィルタ  | 説明                                                                             |
|-----------|--------------------------------------------------------------------------------|
| $project  | 入力のドキュメントに対して、ドキュメントのフィールドの有無指定、およびフィールドのリネームを行い、返却する。また、フィールドに対して計算を行うこともできる。 |
| $match    | 指定したフィールドの検索条件で対象ドキュメントを絞り込み、結果を返却する。                                          |
| $redact   | 入力のドキュメントに対して、ドキュメントの中にある情報で、ドキュメントのフィールドの出力有無を制御して、返却する。                      |
| $limit    | 入力のドキュメントに対して、出力するドキュメント数を制限して、返却する。                                           |
| $skip     | 入力のドキュメントに対して、指定数のドキュメントをスキップして、返却する。                                          |
| $unwind   | 入力のドキュメントに対して、指定した配列の中身を、それぞれ単一のキーに変えたドキュメントにして、それを配列にして、返却しする。|
| $group    | 入力のドキュメントに対して、集約した結果を返却する。                                                     |
| $sort     | 入力のドキュメントに対して、並び替えて、返却する。                                                      |
| $geoNear  | 入力のドキュメントの地理情報を元に、地理的に近い物の順に並び替えて、返却する。                                        |
| $out      | 出力の結果をコレクションに格納する。  |
| $lookup   | 他のコレクションをLeft Outer JOINで結合する。|

このように様々なパイプラインのフィルターがあるため、これをつなぎ合わせることで非常に複雑な集計も計算することが出来ます。特に、MongoDB 3.2から新たに導入された`$lookup`のフィルタは、他のコレクションを結合できるという画期的なものであり、集計する幅が一気に広がりました。このパイプラインをつなぐ集計手法になれてくると、SQLのGROUP BYよりも簡潔に集計を書ける場合があります。


### アプリケーションからの使い方

MongoDBをアプリケーションから利用する場合は、主に３つの方法があります。

一つ目はMongoシェルと呼ばれるCUIベースのツールであり、MongoDB付属のmongoというバイナリを起動すると、MongoDBに接続しjavascriptの文法でインタラクティブにMongoDBを操作することができます。クエリの他にもレプリケーションやシャーディングの設定もこのMongoシェルを通して行われます。主な用途としては、初期構築、保守作業、トラブルシューティングなどであり、OracleのSQL*PlusやMySQLのmysqlコマンドと同じようなものだと思えば良いでしょう。

二つ目は、各プログラミング言語毎に用意されたドライバです。これらはアプリケーションからMongoDBに接続する際にもっとも一般的な方法です。MongoDBが公式に提供しているドライバは、C、C++、C#、Java、Node.js、Perl、PHP、Python、Motor、Ruby、およびScala用のものがあります。これらはMongoDBの有償サポートを購入すると一緒にサポートされます。また、その他にコミュニティーで有志で開発されているドライバもあり、具体的にはActionScript3、C# and .NET、Clojure、ColdFusion、D、Dart、Delphi、Elixir、Entity、Factor、Fantom、F#、Go、Groovy、JavaScript、LabVIEW、Lisp、Lua、MatLab、Objective C、OCaml、Opa、Perl、PowerShell、Prolog、Python、R、REST、Ruby、Scala、Racket (PLT Scheme)、Smalltalkのドライバが2015年11月現在存在しています。

三つ目はREST APIです。HTTPプロトコルを経由してMongoDBのデータを操作することができます。CRUDだけでなくインデックス管理やアクセスコントロールなど、それなりに数多くの機能が提供されていますが、アプリケーションから利用する場合はドライバを用いることが多くREAT APIはあまり利用されていません。

### インデックス

MongoDBは、コレクション単位にインデックスを用意して、検索の際にインデックスを利用して高速に検索ができます。MongoDBのインデックスはRDBと同等に、豊富な種類と様々なオプションが利用可能です。

#### インデックスの種類

MongoDB利用できるインデックスを[[mongo_index]]に整理しました。

{: id="mongo_index" title="MongoDBのインデックスの種類"}
| インデックスの種類 | 説明                                                                          |
|--------------------|-----------------------------------------------------------------------------|
| 単一               | 一つのキーに対してインデックスを付与。主キー以外でインデックスを作成可能。                                       |
| 複合               | 複数のキーに対してインデックスを付与。順序があるため、{a:1,b:1}と{b:1,a:1}ではインデックスの構造が異なる。              |
| マルチキー         | 複数のキーに対してインデックスを付与。順序があるため、{a:1,b:1}と{b:1,a:1}ではインデックスの構造が異なる。              |
| 地理空間           | 地理情報（緯度経度）、空間情報（点、直線、多角形）に対して専用のインデックスを張り、地理空間用のクエリに対応させる。                  |
| テキスト           | アルファベットに対して全文検索のインデックスを作る。日本語データには対応していない。                                  |
| ハッシュ           | キーに対してハッシュ関数を適用して、その値をインデックスに用いる。シャーディング環境において、偏りのあるキーを均等に分散させたい場合に利用するとよい。 |

このように、MongoDBはこのように多種多様なインデックスを提供しています。セカンダリインデックスや複合インデックスはRDBでは当たり前のことですが、実は他のNoSQLではあまり見られない機能です。

#### インデックスの属性

MongoDBではインデックスに対して、属性をつけることができます。[[mongo_index_option]]に整理しました。

{: id="mongo_index_option" title="インデックスの属性一覧"}
|属性   | 説明                     |
|-------------|--------------------------|
|TTL属性 | 生存期間を指定してその期間が過ぎると自動的にドキュメントを削除する|
|パーシャル属性 | 条件を指定して、その条件に合うドキュメントだけをインデックスに含める |
|ユニーク属性 |同じインデックスの値を持つドキュメントを挿入したときにエラーにできる。ただし、ハッシュインデックスには利用できない。また、シャーディング環境においては、シャードキー自体か、シャードキーを最初に指定した複合キーしか利用できない。|
|スパース属性 |インデックスに指定したキーを持っているドキュメントのみインデックスの中に含まれる。稀にしか存在しないキーをインデックスに指定するときに、インデックスサイズを削減できる|

特徴的なのはパーシャル属性であり、これはMongoDB 3.2からの新機能であり、特定の条件を持つドキュメントのみをインデックスに含めることが出来ます。例えば、ユーザデータ管理においてデータの有効フラグが真の場合だけインデックスをつけるといったことが可能であり、インデックスのサイズを削減して、メモリを有効に使うことが出来ます。

また、TTL属性は古いドキュメントを自動的に削除してくれるため、ログなどを格納するときに古いものを勝手に消してくれるため便利です。

#### 実行計画とHINT

RDBではSQLの実行計画をEXLPAINを用いて表示することが出来ますが、MongoDBにも`explain()`メソッドにより同様の情報を得ることが出来ます。またインデックスの利用を強制する`hint()`メソッドも利用できます。これもRDBでは当たりの機能ですがNoSQLで提供しているものは多くありません。

## 性能拡張

MongoDBではシャーディング構成を取り、データとクエリを分散することにより性能を向上させます。また、レプリケーションによりセカンダリからデータを読むことにより読み込みを分散させる事もできます。順に説明してきましょう。

### シャーディングによる性能拡張

#### 概要

MongoDBでは、データを複数のMongoDBに分散して配置して、そのノードに対してクエリを分散することにより、シャーディング構成を形成することができます。例として、３台のMongoDBでシャーディングを行った場合の図を示します。

![MongoDB 3台でシャーディングを行った場合のシステム構成図](image/img_mongo-sharding.png)

図の説明をします。アプリケーションからMongoDBドライバのAPIを呼び出してクエリを発行すると、ドライバはmongosルータと呼ばれるプロセスにアクセスします。mongosルータはデータの配置情報(どのMongoDBにどのデータが入っているか)を知っているため、クエリの内容に従って適切なMongoDBにクエリを割り振ります。

設定サーバは配置情報を永続化するための特別なMongoDBです。mongosルータは設定サーバの情報を読み込んで起動する軽量プロセスです。どちらもMongoDBの中に含まれており、特別にインストールする必要はありません。

#### データの分散方法

データはシャードキーと呼ばれるキーの値によって、その範囲で分散されます。例えば、シャードキーがユーザIDだとすると、ユーザ0～100番までは一つ目のMongoDBtといった感じです。シャードキーはドキュメントの中にある任意の値を指定することができます。また、シャードキーの値は、値をそのまま用いてもよいですし、値のハッシュ値を採用することもできます。

#### クエリの分散方法

クエリの分散はmongosルータによって行われます。例えば、シャードキーを検索条件に含むクエリであれば、シャードキーを元にその範囲を担当しているMognoDBにクエリを転送して、結果をドライバに返します。一方、シャードキーを含まない検索であれば、すべてのMongoDBに問い合わせを転送し、結果をまとめてドライバに返却します。

mognosルータは複数個立てることができるため、mognosルータが単一障害点になることはありません。

#### データの自動再配置

シャーディングでは特定のノードにチャンクが偏った場合に、自動的にチャンクを他のシャードに移動する事ができます。また、チャンクのサイズが大きくなりすぎた場合に、自動的にチャンクを２つに分割します。この２つの機能により、データをクラスタ全体に自動的に分散させ、負荷も分散させています。

また、オンラインでシャードを追加したり削除したりする事が可能で、その場合も上記の２つの動作により、自動的にデータが再配置されます。

### セカンダリ読み込みによる読み込み負荷分散

シャーディングでは読み込み書き込みともに分散されますが、MongoDBのレプリケーションの機能を使うことにより読み取りを更に分散させることが出来ます。

具体的には、MongoDBのドライバの設定により、プライマリからだけではなくセカンダリからも読み込むことができます。レプリカセット内のどのMongoDBから読み込むかはクエリごとに指定できて、セカンダリからラウンドロビンで読んだり、ping応答のはやいセカンダリから読んだり、特定のタグを持つセカンダリから読むなど、柔軟な指定が可能です。

注意点としては、セカンダリから読み込みは結果整合性です。つまりセカンダリから読んだデータは古い可能性があるということです。プライマリからセカンダリへのデータコピーはクエリとは非同期なので、プライマリにデータが書き込また直後はセカンダリにはデータがありません。データのコピーはロングポーリング[^long-polling]という方法により限りなく速くコピーされますが、同期的ではありません。つまり、RDBに実装されている分散トランザクションとは違うということです。

[^long-polling]: ロングポーリングでは、セカンダリからプライマリに差分データを要求しますが、プライマリは更新があるまで応答は待って置き、更新したらその要求に応答します。

## 高可用

MongoDBはレプリケーション構成により、可用性を高めることが出来ます。

### レプリケーションの概要

MongoDBではデータの複製を複数のMongoDBにコピーすることができる、レプリケーションができます。３台のMongoDBでレプリケーションしたときの様子を[[img_mongo_replication]]に示します。

![MongoDB 3台でレプリケーションを行った場合のシステム構成図](image/img_mongo-replication.png){: id="img_mongo_replication"}

図の説明をします。レプリケーションを構成している３台のMongoDBはレプリカセットと呼ばれます。３台のうち１台が書き込みも読み込みも行えるプライマリであり、その他の２台は読み込みしか行えないセカンダリです。プライマリが障害になると、セカンダリ同士で話し合い、その中から１台がプライマリに選出します。新しいプライマリが書き込みを受け付けられるようになると、MognoDBドライバは新しいプライマリに書き込みを行うようになります。シャーディングとは異なりmongosルータや設定サーバのような特別なプロセスは不要です。MongoDBとドライバがあれば構築でき、非常に簡単です。

また、シャーディングと組み合わせることも可能であり、MongoDB 9台を組み合わせた場合は[[img_mongo_repli_shard]]のようになります。

![MongoDB 9台でレプリケーションとシャーディングを行った場合のシステム構成図](image/img_mongo-sharding-replication-1.png){: id="img_mongo_repli_shard"}

この構成ではデータベース用のノードを3つ用意して、それぞれにお互いのレプリカを持たせつつ、プライマリノードを分散して配置することにより、負荷を分散しています。また、シャーディングに必要な設定サーバもそれぞれのノードに配置して、設定サーバも冗長化しています。この構成であれば、一つのノードが障害になっても、負荷分散を継続しつつ、レプリカも存在している状態を継続できます([[img_mongo_repli_shard2]])。

![ノード2が障害になった場合のフェイルオーバ](image/img_mongo-sharding-replication-2.png){: id="img_mongo_repli_shard2"}

### フェイルオーバ

レプリカセット内のMongoDBはお互いにヘルスチェックをしあっており、プライマリが故障すると新しいプライマリを選出するために選挙を行います。新しいプライマリが選出されるまでの間は書き込みが出来ず、新しいプライマリが選出されると書き込みが可能になります。そのため、書き込みの可用性はマルチマスタレプリケーションのNoSQLと比較すると低くなります。

### セカンダリの種類

MongoDBは以下の種類のセカンダリを利用できます。

{:title="セカンダリの種類"}
|種類|説明|
|----|----|
|arbiter|データは持たず、プライマリの選出だけに参加するセカンダリ。偶数台のレプリカセットを組みたい場合に用いる|
|hidden|オンライン処理は受け付けず、プライマリデータ同期だけするセカンダリ。分析やバッチ処理のために用いる |
|delayed|プライマリから一定時間遅れて同期する。コレクションを間違って消したなどのヒューマンエラーの際に役に立つ|

### 書き込み台数指定クエリ

MongoDBではクエリごとに「何台のレプリカに書き込んだらアプリケーションに応答するか」という値を決めることが出来ます。この値はW値と呼ばれます。W値を2に設定した場合、プライマリとセカンダリ一台に書き込みが完了するまでアプリケーションへは成功が帰りません。これにより大事なクエリが確実にレプリケーション出来たことを確認できます。また、応答速度を速くしたければW値を0に設定することにより、書き込み確認を待たなくすることも可能です。他にもクラスタノードの過半数に書いたかどうか、特定のタグを持ったセカンダリに書いたかどうか、といった柔軟な指定も可能です。

### 読み込み整合性(readConcern)

通常のレプリカセットの読み込み負荷分散では、どこか一台から、そのノードにある最も最新のデータを読む動きでしたが。このとき読むデータは、レプリカセットの半数以上に書かれていることが保証されていないため、レプリカセットのの壊れ方によっては失われてしまうデータかもしれませんでした。もし、クラスタとして失うことが「正」であるデータを読んでしまうと、アプリケーションに不整合が起こる可能性があります。

そこで、読み込み整合性(readConcern)という仕組みが導入され、readConcernにmajorutyと指定すると、レプリカノードの過半数にデータが書き込まれている場合に限り読み込みに成功し、そうでないならロールバックする動きとなります。これにより確実にクラスタとして保持されることが保証されるデータだけを読むことができます。

## 運用

### バックアップ

MongoDBは３種類のバックアップ方法があります。

一つ目はファイルシステムを丸ごと取得するバックアップです。MongoDBは一つのディレクトリの中にデータが全て格納されるため、MongoDBを停止しディレクトリ事丸ごとコピーすればバックアップが取得できます。また、MongoDBの起動中に、ディスクのスナップショット機能等でバックアップを取ることも可能ですが、その場合はバックアップから復元する時に仕掛中だったデータの整合性を保つために自動的にリカバー処理が実行されます。

二つ目はmongodumpコマンドやmongoexportコマンドでファイルとしてバックアップを取得する方法です。mongodumpではデータベースの内容をバイナリファイルとして書き出しますが、mongoexportではJSON、CSV、TSVいずれかの形式のテキストファイルに書き出します。どちらのコマンドでも、フィルタを指定して、データの一部を書き出すことができます。

三つ目はマネージドサービスである「MongoDB Ops Manager」を利用した方法です。Ops ManagerではMongoDBの更新ログを定期的に収集し、スナップショット、差分バックアップ、およびポイントインタイムリカバリ[^mms-point-intime-recovery]の機能を提供します。また、シャーディング環境にいおて、すべてのシャードノードのデータをバックアップすることができ、ポイントインタイムリカバリが可能です。これは、上記のファイルシステムバックアップやコマンドによるバックアップでは実現できません。Ops Managerについては[[capter_mongo_ops_manager]]で詳しく紹介します。

[^mms-point-intime-recovery]: ポイントインタイムリカバリとは、時刻を指定してその時間の状態にデータベースを戻す機能です。

### ヒューマンエラー対策(遅延レプリケーション)

コマンドを間違ってデータを消してしまうなどのヒューマンエラーが発生したときに、被害を最小限に押させるために、MongoDBでは遅延レプリケーションという仕組みを持っています。遅延レプリケーションでは、セカンダリを一定時刻前の状態にしておくことができます。例えば10分前の状態でレプリケーションし続けるといったことです。これにより、間違ってデータを消してしまっても遅延しているセカンダリではデータが残っているため、その間にデータを救出するといったことが可能です。

### 監視・稼働統計

mongostatとmongotopというコマンドが利用できます。

mongostatコマンドは、LinuxのvmstatコマンドのようにMongoDBの統計状態をリアルタイムに表示します([[mongo_stat]])。

{: title="mongostatコマンドの出力例" id="mongo_stat"}
~~~
connected to: 127.0.0.1
insert  query update delete getmore command flushes mapped  vsize ...
   410   1200     *0     *0       0     1|0       1    12g  24.4g ...
   360   1211     *0     *0       0     1|0       0    12g  24.4g ...
   372   1922     *0     *0       0     1|0       0    12g  24.4g ...
~~~

mongotopコマンドは、Linuxのtopコマンドのようにコレクション毎の処理時間をリアルタイムに表示します。負荷が集中しているコレクションを探す場合に用います([[mongo_top]])。

{: title="mongotopコマンドの表示例" id="mongo_top"}
~~~
ns                     total    read    write  2015-07-10T04:56:52+09:00
mydb.mycol              6ms     6ms      0ms
admin.system.roles      0ms     0ms      0ms
admin.system.version    0ms     0ms      0ms

ns                     total    read    write  2015-07-10T04:56:53+09:00
mydb.mycol             44ms    44ms      0ms
admin.system.roles      0ms     0ms      0ms
admin.system.version    0ms     0ms      0ms
~~~

他にもサーバの状態をJSON形式で詳細に表示するコマンドがありますが紹介は割愛します。

### バージョンアップ

マイナーバージョンアップやパッチバージョンアップであれば、mongodの実行バイナリの置き換えで実施できます。メジャーバージョンアップであれば、データファイルのフォーマット変更作業などを伴うことがあります。

バージョンアップの際は、レプリケーションを構成している複数台を順番にバージョンアップするローリングアップデートが可能です。

### MongoDB Ops Manager
{: id="capter_mongo_ops_manager"}

MongoDB Ops Managerとは、MongoDBの監視、アラート、バックアップ、自動バージョンアップ、自動デプロイを行うことができるアプリケーションです。従量課金のクラウドタイプと、有償サブスクリプションによるオンプレミス型の二つの提供形態があります。

クラウドタイプでは、手元のMongoDBが動作している環境にOps Managerのエージェントプログラムをインストールすることにより、エージェントが各MongoDBと通信し、稼働統計情報やバックアップのための更新情報をクラウドにPUSHで送信します。またクラウド側からの指示で、手元の環境のバックアップ・リストアや自動バージョンアップを行います[[img_mongo_opsmanager_system]]。

![Ops Managerのシステム構成](image/img_mongo_opsmanager_system.png){: id="img_mongo_opsmanager_system"}


[[img_mongo_opsmanager]]にOps Managerの監視画面のスナップショットをのせます。

![Ops Managerの画面](image/img_mongo_opsmanager.png){: id="img_mongo_opsmanager"}


{: title="Ops Managerの前身"}
<div class="note">
MongoDB Ops Managerは、以前はMongoDB Management Serviceと呼ばれていました。その頃は自動バージョンアップや自動デプロイ機能はありませんでした。

さらに昔はMongoDB Monitoring Serviceと呼ばれており、この時はバックアップ機能がなく、モニタリングとアラートのみのサービスでした。
</div>



## セキュリティ

MongoDBではセキュリティに関して幾つか機能を提供しています。

### 通信暗号化 

SSLでMongoDBドライバとMongoDB間を通信を暗号化できます。

### データ暗号化

有償版のMongoDBでは、データを暗号化して格納できます。これはHIPAA, PCI-DSS, FERPAといったセキュリティの標準化に準拠しています。

### アクセスコントロール

ユーザやロールを作り、付与された権限ごとにできる操作を制限することができます。制限できる操作はデータべースのアクセス、コレクションのアクセス、管理オペレーション、稼働統計の取得など様々です。

### 監査

有償版のMongoDBでは、監査レポートを出力することができます。

## 出来ないこと

RDBには複数のクエリをアトミックに実行するトランザクションがありますが、MongoDBにはありません。MongoDBがアトミックに処理を行える対象は、一つのドキュメントに限ります。例えば`db.collection.find()`とクエリを発行して、すべてドキュメントを取得しようとしたときに、最初のドキュメントを取得してから最後のドキュメントを取得するまでに、ほかのアプリケーションが当該コレクションを更新してしまう可能性があります。

また、RDBでは複数のテーブルを結合して一貫して取得することができます。「一貫して取得」の意味は、一つのテーブルを取得して、もう一つのテーブルのデータと突き合わせている間に、ほかのクエリが割り込んできて結合先のテーブルを更新するといったことはないということです。トランザクションの中にいると言い換えてもよいでしょう。一方、MongoDBでは結合ができません。結合のようなことをしたければ、他ドキュメントのキーを格納して起き、アプリケーションで複数回クエリを投げて、結果をアプリケーションで結合する方法が考えられます。しかし、この方法は一貫した結果を取得できません。なぜならば、クエリを複数回投げている間に、他のアプリケーションが割り込んで結合対象のドキュメントを更新してしまう可能性があるためです。

さらに、MongoDBには参照整合性がありません。つまり、あるドキュメントと関連するドキュメントを一貫して消したり更新したりすることはできません。

トリガ、ストアドプロシジャ、シーケンス、ビュー、副問い合わせ、日本語によるLIKE検索、日本語の全文検索などの機能はありません。

レプリケーション構成においてレプリカ内の複数のMongoDBを書き込むことはできません。プライマリノードしか書くことはできず、マルチマスタレプリケーションではありません。

インデックスを用いないソートをする場合に32Mバイトのメモリ制限があります。

MongoDB 2.xまでは利用するメモリを制限できません。空いているメモリを使えるだけ使います。

## 主なバージョンと特徴

### バージョンのつけ方

MongoDBのバージョンは3つの数字からなり、メジャーバージョン、マイナーバージョン、パッチバージョンの３つです。例えばMongoDB 2.6.9であれば、メジャーバージョンが2で、マイナーバージョンが6で、パッチバージョンが9となります。

メジャーバージョンは大きな構成変更がなされたときに行われ、マイナーバージョンが異なれば互換性は一部なくなります。具体的にはメジャーバージョン2とメジャーバージョン3では、アプリケーションからの利用方法はほぼ同じですが、データの格納方法が異なるため、マイグレーションの作業が伴います。

マイナーバージョンアップは、互換性があるバージョンアップであり、例えば2.4から2.6に上がると、古い機能はそのまま使え新しい機能が追加されているという具合になります。マイグレーションの作業はほとんど発生しません。また、偶数番号は安定版、奇数番号は開発版となっており、奇数番号のものは本番環境で利用してはいけません。

パッチバージョンは、パッチが当たってバグがつぶれるたびに、バージョンが上がります。

### 主なバージョンとその機能

2015年11月時点での主なバージョンとその機能は以下の通り

{: title="主なバージョンとその機能"}
|バージョン|説明 |
|----------|---------------------|
|2.6       | 既に開発が終わっている2系の最終バージョン。バグフィックスだけは行われている。|
|3.0       | 新しくWiredTigerストレージエンジンの導入。ロックの単位がデータベース単位だったものがドキュメント単位になった、メモリ利用量制限できるようになった等の変更あり。|
|3.2       | 2015年12月にリリースされた最新バージョン。キュメントのバリデーション、部分的インデックス、アグリゲーション時に他のコレクションをJOINできる機能などが主な新機能|

##  国内のサポート体制

2015年11月時点で、MongoDBの日本法人は存在しませんが、株式会社野村総合研究所、日本システムウエア株式会社、およびクリエーションライン株式会社が日本でサブスクリプション販売代理及び技術サポート提供を行っています。

## ライセンス体系

MongoDBは無償でオープンソースのAGPLライセンスと、有償の商用ライセンスの２つのライセンスがあります。
有償版で提供される拡張機能については、2015年12月時点で以下のように定義[^mongo-enterprise]されています。

* Ops Manager のオンプレミス版かCloud Manager Premiumを利用できる
* Red Hat Identity Management の認定
* KerberosとLDAP認証
* 監査機能
* SNMPサポート
* 暗号化ストレージの利用
* インメモリーストレージの利用
* MongoDB Compass(データ可視化UIツール)の利用
* BIコネクター
* Windows、 RedHat/CentOS、 Ubuntu、 Amazon Linuxでのプラットフォーム認定
* プライベート、オンデマンドトレーニング
* 技術サポートが利用できる
* 技術サポートのSLA保証
* 緊急パッチ
* ライセンスが商用ライセンスになる

[^mongo-enterprise]: MongoDB社のMongoDB Enterprise Advanced Datasheetから引用 http://info-mongodb-com.s3.amazonaws.com/MongoDB_Enterprise_Advanced_Datasheet.pdf

## 効果的な学習方法

英語が読めるのであれば、MongoDBの公式ドキュメント[^mongo-document]を読むのが最も効果的な学習方法です。簡単なイントロダクションや設定値の一覧などはもちろんのこと、シャーディングの詳細な動作原理やドキュメントの設計方法など、有用な情報が数多く記載されています。

[^mongo-document]: https://docs.mongodb.org/manual/

日本語の情報であれば、MongoDBイン・アクション[^mongodb-inaction]を読むのが良いでしょう。MongoDBの基本的な事項はほぼすべて網羅して書いてあります。ただし、記載内容がMongoDB 2系の内容であるため、ストレージエンジンはMMAPのことについてのみ書いてあります。WiredTigerについては公式ドキュメントを見るのが良いでしょう。

[^mongodb-inaction]: MongoDBイン・アクション Kyle Banker 著, Sky株式会社 玉川 竜司 訳

## その他

### 便利な機能一覧

その他の便利な機能は以下の通り。

{: title="その他便利な機能一覧"}
| 機能                           | 説明                                                                                                  | ユースケース         |
|--------------------------------|-------------------------------------------------------------------------------------------------------|----------------|
| 地理空間クエリ・インデックス   | ２Dや３Dのデータを格納し、それに対して交点や近傍などの検索をかけることができる。アプリでのつくり込不要 | 地図アプリのデータベース   |
| キャップ付きコレクション       | サイズを指定したコレクションを作れる | バッファ |
| 生存期間指定インデックス       | 保存期限を指定したコレクションを作り、自動的に古いドキュメントを引き落とせる | ログ保管 |
| データ圧縮                     | MongoDB 3から利用できるWired Tigerのストレージエンジンでは、データやインデックスを圧縮して格納できる | 大容量データ保存 |
| GridFS                         | シャーディングの機能を利用して、大容量ファイル(16M以上)を扱うことができるAPIを提供する。このAPI経由でファイルを保存すると勝手に分割して、シャーディングで分散保存してくれる。| 大容量ファイルシステム |
| ジャーナリング                 | 単一ドキュメントに対して、書き込みの一貫性が保持できる。 | 突然の電源停止等に対応したい |
| データ可視化(MongoDB Compass)  | MongoDBに入っているデータを可視化するツール[[img_mongo_compass]] | データ管理|

![MongoDB Compassによるデータの可視化](image/img_mongo_compass.png){: id="img_mongo_compass"}

